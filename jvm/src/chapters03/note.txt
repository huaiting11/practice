运行时数据区概述及线程（内存）
1 概述
2 线程
简单概述：

执行引擎
 内存是非常重要的系统资源，是硬盘和cpu 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。
 JVM 内存布局规定了 Java 在运行过程中内存申请，分配，管理的策略，保证了JVM 的高效 稳定运行
 不同的JVM 对于内存 的划分 方式 和管理机制 存在着 部分差异，结合jvm 虚拟机规范，
 cpu 读的都是内存的区域，cpu 的交互对象就是内存

进程/线程
线程是一个 程序里的运行单元。JVM 允许一个应用有多个并行的执行。

在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。 当一个Java 线程准备好执行以后，
此时一个操作系统的本地线程也同时创建，Jav 线程执行终止后，本地线程也会回收。
操作系统负责所有 线程的安排 调度到任何一个可用的cpu上，一旦本地线程初始化成功，它就会调用Java 线程中
的run() 方法

一、程序计数器（PC 寄存器）
1. PC Register 介绍
 一个栈帧 就是一个方法：包括局部变量表，操作数栈，动态链接，方法返回值
 执行引擎调用pc 寄存器 一句一句 执行代码
 它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域。

 在jvm 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期和线程的生命周期保持一致。

 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法
 的JVM指令地址：或者，如果是在执行native（） 方法，则是未指定值（undefined）

 它是程序控制流的指示器，分支。循环，跳转，异常处理。线程恢复等基础功能都需要依赖这个计数器来完成

 字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

 它是唯一一个在Java 虚拟机规范中没有规定任何oom 情况的区域
2. 举例说明

stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2

    指令地址（偏移地址） 操作指令
3. 两个常见问题
使用pc 寄存器存储字节码指令地址有什么用呢？
为什么使用pc 寄存器记录当前线程的执行地址？
 因为cpu需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
JVM的字节码解释器就需要通过改变pc 寄存器的值来明确下一条应该执行什么样的
字节码指令。
pc 寄存器为什么被设定为线程私有的？
我们都知道所谓的多线程在一个特定的时间段内只会执行其中一个线程的方法，cpu会不
停地切换做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？
为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为
每一个线程都分配一个pc 寄存器。 这样一来，各个线程之间便可以进行独立计算，
从而不会出现相互干扰的情况。
由于cpu 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个
处理器或者多核处理器中一个内核，只会执行某个线程中的一条指令。
这样必然导致经常中断或恢复。每个线程在创建后，都会出创建独立的程序计数器。

05 虚拟机栈
1  虚拟机栈概述
  优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的
  指令。
  栈是运行时的单位，而堆是存储的单位。
  即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据
  存储的问题，即数据怎么放，放在哪儿。
  java虚拟机栈是什么：
  Java 虚拟机栈 （Java Virtual Machine Stack） ，早期也叫java 栈。每个线程在
  创建时都会创建一个虚拟机栈。其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java
  方法调用。
  线程私有
  生命周期：
     生命周期和线程一致。
  作用： 主管java 程序的运行，它保存方法的局部变量、部分结构、并参与方法的调用与返回。
  栈的优点：
    栈是一种快速有效地分配存储方式，访问速度仅次于程序计数器。
    jvm直接对java 栈的操作只有两个：
       每个方法执行，伴随着进栈（入栈、压栈）
       执行结束后的出栈工作
    对于栈来说 不存在垃圾回收问题
    栈中可能出现的异常：
    java 虚拟机规范允许java 栈的大小是动态的或者是固定不变的。
    如果采用固定大小的java虚拟机栈，那每一个线程的java虚拟机容量可以在线程创建的时候独立
    选定，如果线程请求分配的栈容量超过java 虚拟机栈允许的最大容量，java虚拟机即将会
    抛出一个StackOverflowError 异常。
    如果java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建
    新的线程时没有足够的内存去创建对应的虚拟机栈，那么java虚拟机栈将会抛出一个
    OutOfMemoryError 异常;

2  栈的存储单位（栈帧）
   每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
   在这个线程上正在执行的每个方法都各自对应一个栈帧。
   栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
   不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个
   栈帧之中引用另外一个线程的栈帧。

   如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行
   结果，给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新

   java方法有两种返回函数的方式，一种是正常的函数返回，使用return 指令
   另外一种是抛出异常，不管使用哪种方式，都会导致栈帧被弹出。
  栈帧的内部结构：
  每个栈帧中存储着：
     局部变量表（Local Variables）
     操作数栈（Operand Stack） （或表达式栈）
     动态链接（或指向运行时常量池的方法引用）
     方法返回地址（或方法正常退出或者异常退出的定义）
     一些附加信息
3  局部变量表
局部变量也被称之为局部变量数组或本地变量表

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量。这些数据类型
包括各类基本数据类型、对象引用，以及returnAddress类型。

由于局部变量表示建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。

局部变量表所需要的容量大小是在编译器确定下来的，并保存在方法的Code属性的maximum
local variables 数据项中，在方法运行期间是不会改局部变量表的大小的。

方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套代用次数越多，对一个函数而言，
它的参数和局部变量越多，使得局部变量膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大
的需求，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

局部变量表中的变量只在当前方法调用中有效。在方法执行中，虚拟机通过使用局部变量表完成参数值
到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随着销毁。

关于Slot 的理解：
JVM 会为局部变量表中的每一个solt 都分配一个访问索引，通过这个索引即可成功访问局部变零
中指定的局部变量值。

当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到
局部变量中的每一个Slot 上。

如果需要访问局部变量表中一个64bit 的局部变量值时，只需使用前一个索引即可，
（比如：访问long 或 double 类型变量）

如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this 将会存放在 index 为0 的slot
处，其余的参数按照 参数表 顺序继续排列。

举例： 静态变量 与 局部变量的对比。。。。
 参数表 分配完毕之后，再根据方法体内定义的变量的顺序和作用域 分配。
 我们知道类变量有两次初始化的机会，第一次 是在  “准备阶段” ，执行系统初始化，对类变量
 设置零值，另一次则是在 “初始化阶段”，赋予程序员在代码中定义的初始值。
 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则
 必须认为的初始化，否则无法使用，
 public void test(){
    int i = ;

 }

 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部 变量表中直接或间接引用的对象都
 不会被回收。

4  操作数栈
5  代码追踪
6  栈顶缓存技术
7  动态链接
8  方法的调用：解析与分派
9  方法返回地址
10  一些附加信息
11  栈的相关试题
