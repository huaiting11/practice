栈： 可以用数组或者链表来实现都是可以的，只不过满足特定条件的 数组或者链表

每一个独立的栈帧中 除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以
称之为表达式栈。
操作数栈：

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈
（push）/ 出栈（pop）
   某一些字节码指令将值压入操作数栈，其余的字节码指令将操作数去取出栈，使用
   它们后再结果压入栈。
   比如：执行复制、交换、求和等操作。

如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新pc寄存器
中下一条需要执行的字节码指令。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，
同时在类加载过程中的类校验阶段的数据流分析阶段要再次验证。

另外，我们说java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。

字节码指令在执行过程中cpu 是不认识的，所以在执行过程中，执行引擎 不仅用到了操作数栈，
还把字节码指令 翻译成 机器指令 让cpu 去运行。

操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间

操作数栈就是jvm执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧就会随之被
创建出来，这个方法的操作数栈是空的。

每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，
保存在方法的Code 属性中，为max_stack 的值。

栈中的任何一个元素都是可以任意的Java 数据类型。
  32bit 的类型占用一个栈单位深度
  64bit 的类型占用两个栈单位深度
操作数栈并非采用访问索引的方式进行数据访问的，
而是只能通过标准的入栈和出栈操作来完成一次数据访问

栈顶缓存技术：
前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要更多的入栈
和出栈指令，这同时也就意味着将更多的指令分派次数和内存读、写次数

由于操作数是存储在内存中的，因此频繁地执行内存读、写操作必然会影响执行速度，为了解决这个问题
，HotSpot jvm 的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理cpu 寄存器中，


动态链接：

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了
支持当前方法能够实现动态链接  比如： invokedynamic指令

在java 源文件 被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic reference）
保存在class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中
指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转化为调用方法的直接引用

为什么需要常量池：
常量池的作用，就是为了提供一些符号和常量，便于指令的识别。

在jvm 中，将符号引用转化为调用方法的直接引用 与方法的绑定机制相关

静态链接：
当一个字节码文件被装进jvm内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下
将调用的符号引用转化为直接引用的过程称之为静态链接。

动态链接：
如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期间将调用方法的符号引用转换为直接引用，
由于这种引用转化过程具备动态性，因此也就被称之为动态链接。

方法的调用：

早期绑定和晚期绑定

早期绑定是在编译期就能够确定的

晚期绑定在运行期间才能知道

虚方法和非虚方法

如果方法在编译就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。

静态方法，私有方法，final 方法，实例构造器，父类方法都是非虚方法。

其他方法称为虚方法。

虚拟机提供了以下几条方法调用指令：
  普通调用指令：
  1.invokestatic:调用静态方法，解析阶段确定唯一方法版本
  2.invokespecial:调用<init> 方法，私有及父类方法，解析阶段确定唯一方法版本
  3.invokevirtual：调用所有虚方法 final方法 调用的是这个
  4.invokeinterface：调用接口方法

  动态调用指令:
   5 invokedynamic:动态解析出需要调用的方法，然后执行

   前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持用户确定方法版本
   其中invokestatic 指令和invokespecial指令调用的方法称为非虚方法，其余的（final）称为虚方法


  java语言中方法重写的本质：
     1.找到操作数栈顶的第一个元素所执行的对象的实际类型，记做c。
     2.如果在过程结束：如果不通过类型c 中找到与常量中的描述符合简单名称
     都相符的方法，则进行访问权限校验，如果通过则返回
     这个方法的直接引用，查找过，
     3，否则，按照继承关系从下到上依次对c 的各个父类进行第 2 步的搜索和验证过程

  在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程
  中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。
  因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表，（非虚方法
  不会出现在表中）来实现，使用索引来替代查找。

  每一个类中都有一个虚方法表，表中存放着各个方法的实际入口。

  那么虚方法表什么时候被创建？

  虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，
  jvm 会把该类的方法表也初始化完毕。

 方法返回地址：
   存放调用该方法的pc寄存器的值。 pc 寄存器存着 下次要执行的指令地址的值。

 一个方法的结束，有两种方式：

    正常执行完成
    出现未处理的异常，非正常退出

    无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出
    时，调用者的pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令
    的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般
    不会保存这部分信息。

    本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量
    表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置pc 寄存器值等，让
    调用者方法继续执行下去。

    正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会
    给他的上层调用者产生任何的返回值。






